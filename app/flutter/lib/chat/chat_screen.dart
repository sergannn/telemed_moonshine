import 'package:flutter/material.dart';
import 'dart:async';
import 'dart:convert';
import 'proactivity/proactivity_manager.dart';
import 'package:vibration/vibration.dart';
import 'chat_logic.dart';
import 'chat_message_model.dart';
import 'services/voice_service.dart';
import 'services/proactivity_service.dart';
import 'hdt_suggestions.dart';

const String SYSTEM_PROMPT = '''
You are a helpful AI assistant created by MTS RnD, providing a generative user interface. Your primary language of communication is Russian. You are designed to assist users with various tasks and queries.

In the message history, you may encounter messages containing the element <tool_summary>...</tool_summary>. This indicates that you have generated a user interface to help solve the user's task. The user is free to interact with this interface, and you can refer to it during your discussion.

Your role is to engage in conversation, answer questions, and provide assistance while keeping in mind the following:

1. Communicate primarily in Russian unless otherwise specified.
2. Utilize and reference any generated user interfaces when appropriate.
3. Offer clear, concise, and helpful responses.
4. Maintain a friendly and professional tone throughout the interaction.
5. Adapt your responses based on the user's needs and the context of the conversation.

Remember to always prioritize user safety and adhere to ethical guidelines in your interactions.
You are not allowed to use "<tool_summary>...</tool_summary>" construction in your answer. It can only be generated by tool.
''';

class ChatScreen extends StatefulWidget {
  @override
  _ChatScreenState createState() => _ChatScreenState();
}

class _ChatScreenState extends State<ChatScreen> {
  late final ChatLogic _chatLogic;
  late final ProactivityService _proactivityService;
  final List<ChatMessageModel> _messages = [];
  final TextEditingController _textController = TextEditingController();
  String _botStatus = '';
  int _retryCount = 0;
  bool _isVoiceMode = false;
  bool _isRecording = false;
  String _selectedLanguage = 'ru-RU'; // Default language

  bool _isDarkTheme = false; // Current theme

  // Background images array
  final List<String> _backgroundImages = [
    "assets/images/background1.jpg",
    "assets/images/background2.jpg",
    "assets/images/background3.jpg",
  ];

  int _selectedBackgroundIndex = 0; // Selected background index

  List<Map<String, dynamic>> chatHistory = [
    {'role': 'system', 'content': SYSTEM_PROMPT},
  ];

  List<Map<String, String>> _nowSuggestions = [];
  List<Map<String, String>> _laterSuggestions = [];
  bool _isSuggestionsLoading = true;

  late StreamSubscription<ProactivityTrigger> _triggerSubscription;

  @override
  void initState() {
    super.initState();
    _chatLogic = ChatLogic();
    _proactivityService = ProactivityService();
    _triggerSubscription =
        ProactivityManager().triggerStream.listen(_handleProactivityTrigger);
    _loadSuggestions();
  }

  Future<void> _loadSuggestions() async {
    final hdtSuggestions = HDTSuggestions();
    final suggestions = await hdtSuggestions.getSuggestions();

    setState(() {
      _nowSuggestions = suggestions['now'] ?? [];
      _laterSuggestions = suggestions['future'] ?? [];
      _isSuggestionsLoading = false;
    });
  }

  @override
  void dispose() {
    _triggerSubscription.cancel();
    super.dispose();
  }

  Future<void> _handleProactivityTrigger(ProactivityTrigger trigger) async {
    setState(() => _botStatus = 'Proactivity trigger received');

    final triggerName = trigger.name;
    final triggerReason = trigger.reason;
    final triggerText = "This is trigger from $triggerName: $triggerReason";

    setState(() => _botStatus = 'Trigger processing');
    final proactivityResult =
        await _proactivityService.processTrigger(triggerName, triggerReason);

    if (proactivityResult['explanation'] != null) {
      final explanationMessage = ChatMessageModel(
          text: proactivityResult['explanation']!, isUser: false);
      _addBotMessage(explanationMessage);
      chatHistory
          .add({'role': 'assistant', 'content': explanationMessage.text});
    }

    if (proactivityResult['command'] != null) {
      final toolName =
          await _chatLogic.findSuitableTool(proactivityResult['command']!);

      if (toolName.isNotEmpty) {
        setState(() => _botStatus = 'Obtaining tool parameters');

        final toolParameters = await _chatLogic.getToolParameters(
            toolName, proactivityResult['command']!);

        try {
          final botMessage =
              await _chatLogic.executeTool(toolName, toolParameters);

          _addBotMessage(botMessage);

          if (botMessage.toolSummary != null) {
            chatHistory
                .add({'role': 'assistant', 'content': botMessage.toolSummary!});
          } else {
            chatHistory.add({'role': 'assistant', 'content': botMessage.text});
          }
        } catch (e) {
          // Ignore error and do not add message
          print('Error executing tool: $e');
        }
      }
    }

    // Clear status after a short delay
    await Future.delayed(Duration(seconds: 2));
    setState(() => _botStatus = '');
  }

  void _addBotMessage(ChatMessageModel botMessage) {
    setState(() {
      _messages.insert(0, botMessage);
      chatHistory.add({
        'role': 'assistant',
        'content': botMessage.toolSummary ?? botMessage.text
      });
    });
    _logMessageHistory();
  }

  void _toggleInputMode() {
    setState(() {
      _isVoiceMode = !_isVoiceMode;
    });
  }

  Future<void> _handleVoiceInput() async {
    setState(() {
      _isRecording = true;
    });

    try {
      final recognizedText = await _chatLogic.convertSpeechToText(
        _selectedLanguage,
        (bool isListening) {
          setState(() {
            _isRecording = isListening;
          });
        },
      );

      setState(() {
        _isRecording = false;
      });

      if (recognizedText.isNotEmpty) {
        _handleSubmitted(recognizedText);
      }
    } catch (e) {
      print("Error in voice recognition: $e");
      setState(() {
        _isRecording = false;
      });
    }
  }

  void _stopVoiceRecording() {
    _chatLogic.stopSpeechRecognition();
    setState(() {
      _isRecording = false;
    });
    Vibration.vibrate(duration: 50);
  }

  void _handleSubmitted(String text) async {
    if (text.trim().isEmpty) {
      return;
    }

    _textController.clear();
    ChatMessageModel userMessage = ChatMessageModel(text: text, isUser: true);

    setState(() {
      _messages.insert(0, userMessage);
      _botStatus = 'Thinking...';
      chatHistory.add({'role': 'user', 'content': text});
    });

    // Log the user message
    _logMessageHistory();

    try {
      await _processMessageWithStatus(text, chatHistory);
    } catch (e) {
      setState(() {
        _botStatus = 'Error occurred. Please try again.';
      });
    }

    setState(() {
      _botStatus = '';
      _retryCount = 0;
    });
  }

  Future<void> _processMessageWithStatus(
      String text, List<Map<String, dynamic>> chatHistory) async {
    setState(() => _botStatus = 'Selecting tool...');
    final toolName = await _chatLogic.findSuitableTool(text);

    if (toolName.isNotEmpty) {
      setState(() => _botStatus = 'Choosing parameters...');
      Map<String, dynamic> toolParameters;
      int _retryCount = 0; // Retry count initialization

      do {
        try {
          toolParameters = await _chatLogic.getToolParameters(toolName, text,
              chatHistory: chatHistory);
          break;
        } catch (e) {
          _retryCount++;
          setState(() => _botStatus =
              'Retrying parameter selection (Attempt $_retryCount)...');
          if (_retryCount >= 3) rethrow;
        }
      } while (true);

      setState(() => _botStatus = 'Executing tool...');
      final botMessage = await _chatLogic.executeTool(toolName, toolParameters);

      setState(() {
        _messages.insert(0, botMessage);
        chatHistory.add({
          'role': 'assistant',
          'content': botMessage.toolSummary ?? botMessage.text
        });
      });

      _logMessageHistory();

      if (_isVoiceMode) {
        await _chatLogic.speakText(botMessage.text);
      }
    } else {
      setState(() => _botStatus = 'Generating response...');

      final botMessage =
          await _chatLogic.generateLLMResponseWithHistory(text, chatHistory);

      setState(() {
        _messages.insert(0, botMessage);
        chatHistory.add({'role': 'assistant', 'content': botMessage.text});
      });

      _logMessageHistory();

      if (_isVoiceMode) {
        await _chatLogic.speakText(botMessage.text);
      }
    }
  }

  void _logMessageHistory() {
    // print('Chat history:');
    // print(jsonEncode(chatHistory));
  }

  Widget _buildMessage(ChatMessageModel message) {
    bool isUserMessage = message.isUser;
    bool isToolMessage = message.isTool;

    return KeyedSubtree(
      key: message.key, // Use key here
      child: GestureDetector(
        onTap: () {
          if (_isVoiceMode && !isUserMessage) {
            _chatLogic.speakText(message.text);
          }
        },
        child: Container(
          margin: EdgeInsets.symmetric(vertical: 10.0),
          child: Row(
            mainAxisAlignment:
                isUserMessage ? MainAxisAlignment.end : MainAxisAlignment.start,
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              if (!isUserMessage) ...[
                CircleAvatar(
                  backgroundColor: Color.fromARGB(255, 222, 189, 189),
                  child: Text('B', style: TextStyle(color: Colors.black)),
                ),
                SizedBox(width: 16.0),
              ],
              Flexible(
                child: Column(
                  crossAxisAlignment: isUserMessage
                      ? CrossAxisAlignment.end
                      : CrossAxisAlignment.start,
                  children: [
                    if (!isToolMessage)
                      Container(
                        padding: EdgeInsets.all(12.0),
                        decoration: BoxDecoration(
                          gradient: isUserMessage
                              ? const LinearGradient(
                                  colors: [
                                    Color.fromARGB(255, 159, 159, 159),
                                    Color.fromARGB(255, 103, 103, 103),
                                    Color.fromARGB(255, 181, 47, 51),
                                  ],
                                  begin: Alignment.centerLeft,
                                  end: Alignment.centerRight,
                                )
                              : const LinearGradient(
                                  colors: [
                                    Color.fromARGB(255, 222, 189, 189),
                                    Color.fromARGB(255, 212, 211, 219),
                                  ],
                                  begin: Alignment.centerLeft,
                                  end: Alignment.centerRight,
                                ),
                          borderRadius: BorderRadius.circular(16.0),
                        ),
                        child: Text(
                          message.text,
                          style: TextStyle(
                            color:
                                isUserMessage ? Colors.white : Colors.black87,
                          ),
                        ),
                      ),
                    if (isToolMessage && message.toolWidget != null)
                      Container(
                        margin: EdgeInsets.only(top: 8.0),
                        child: message.toolWidget!,
                      ),
                  ],
                ),
              ),
              if (isUserMessage) ...[
                SizedBox(width: 16.0),
                CircleAvatar(
                  backgroundColor: Color.fromARGB(255, 181, 47, 51),
                  child: Text('U', style: TextStyle(color: Colors.white)),
                ),
              ],
            ],
          ),
        ),
      ),
    );
  }

  void _handleSuggestionTap(String suggestionText) {
    _handleSubmitted(suggestionText);
  }

  Widget _buildSuggestionsRow() {
    return SingleChildScrollView(
      scrollDirection: Axis.horizontal,
      child: Row(
        children: [
          ..._nowSuggestions.map((suggestion) {
            suggestion['text'] = 'Что помогает от мигрени?';
            return Padding(
              padding: const EdgeInsets.symmetric(horizontal: 4.0),
              child: GestureDetector(
                onTap: () => _handleSuggestionTap(suggestion['text']!),
                child: Container(
                  padding: const EdgeInsets.symmetric(
                      horizontal: 12.0, vertical: 8.0),
                  decoration: BoxDecoration(
                    gradient: LinearGradient(
                      colors: [
                        Colors.blue,
                        Colors.purple
                      ], // Gradient for "now"
                      begin: Alignment.centerLeft,
                      end: Alignment.centerRight,
                    ),
                    borderRadius: BorderRadius.circular(16.0),
                  ),
                  child: Text(
                    suggestion['text']!,
                    style: const TextStyle(color: Colors.white),
                  ),
                ),
              ),
            );
          }),
          ..._laterSuggestions.map((suggestion) {
            return Padding(
              padding: const EdgeInsets.symmetric(horizontal: 4.0),
              child: GestureDetector(
                onTap: () => _handleSuggestionTap(suggestion['text']!),
                child: Container(
                  padding: const EdgeInsets.symmetric(
                      horizontal: 12.0, vertical: 8.0),
                  decoration: BoxDecoration(
                    gradient: LinearGradient(
                      colors: [Colors.red, Colors.pink], // Gradient for "later"
                      begin: Alignment.centerLeft,
                      end: Alignment.centerRight,
                    ),
                    borderRadius: BorderRadius.circular(16.0),
                  ),
                  child: Text(
                    suggestion['text']!,
                    style: const TextStyle(color: Colors.white),
                  ),
                ),
              ),
            );
          }),
        ],
      ),
    );
  }

  Widget _buildTextComposer() {
    return IconTheme(
      data: IconThemeData(color: Theme.of(context).colorScheme.primary),
      child: Column(
        children: [
          //   Text("a"),
          if (!_isSuggestionsLoading && _nowSuggestions.isNotEmpty)
            _buildSuggestionsRow(),
          Container(
            color: Colors.blueGrey.withOpacity(0.1),
            margin: EdgeInsets.symmetric(horizontal: 8.0),
            child: Row(
              children: [
                IconButton(
                  icon: Icon(_isVoiceMode ? Icons.keyboard : Icons.mic),
                  onPressed: _toggleInputMode,
                ),
                if (_isVoiceMode)
                  DropdownButton<String>(
                    value: _selectedLanguage,
                    items: [
                      DropdownMenuItem(child: Text("English"), value: "en-US"),
                      DropdownMenuItem(child: Text("Русский"), value: "ru-RU"),
                    ],
                    onChanged: (String? newLanguage) {
                      setState(() {
                        if (newLanguage != null) {
                          _selectedLanguage = newLanguage;
                        }
                      });
                    },
                  ),
                Flexible(
                  child: _isVoiceMode
                      ? Container()
                      : TextField(
                          controller: _textController,
                          onSubmitted: _handleSubmitted,
                          decoration: InputDecoration.collapsed(
                              hintText: 'Send a message'),
                        ),
                ),
                SizedBox(width: 8.0),
                GestureDetector(
                  onTap: _isVoiceMode
                      ? (_isRecording ? _stopVoiceRecording : _handleVoiceInput)
                      : null,
                  child: CircleAvatar(
                    radius: 30.0,
                    backgroundColor: _isVoiceMode
                        ? (_isRecording ? Colors.red : Colors.blue)
                        : Colors.grey,
                    child: Icon(
                      _isVoiceMode
                          ? (_isRecording ? Icons.stop : Icons.mic)
                          : Icons.keyboard,
                      color: Colors.white,
                      size: 28.0,
                    ),
                  ),
                ),
                SizedBox(width: 8.0),
                if (!_isVoiceMode)
                  IconButton(
                    icon: Icon(Icons.send),
                    onPressed: () {
                      if (_textController.text.trim().isNotEmpty) {
                        _handleSubmitted(_textController.text);
                      }
                    },
                  ),
              ],
            ),
          ),
        ],
      ),
    );
  }

  void _toggleTheme() {
    setState(() {
      _isDarkTheme = !_isDarkTheme;
    });
  }

  PreferredSizeWidget my_AppBar() {
    return AppBar(
      title: Text('Помощник',
          style: TextStyle(
              color: _isDarkTheme
                  ? const Color.fromARGB(255, 28, 28, 28)
                  : const Color.fromARGB(255, 231, 231, 231))),
      backgroundColor: const Color.fromARGB(255, 112, 112, 112),
      actions: [
        /* IconButton(
          icon: Icon(Icons.close),
          onPressed: () {
            Navigator.pop(context); // Go back to the previous screen
          },
        ),*/
        IconButton(
          icon: Icon(_isDarkTheme ? Icons.wb_sunny : Icons.nights_stay),
          onPressed: _toggleTheme, // Toggle theme button
        ),
        // Background selection
        PopupMenuButton<int>(
          onSelected: (int index) {
            setState(() {
              _selectedBackgroundIndex = index;
            });
          },
          itemBuilder: (BuildContext context) {
            return List.generate(_backgroundImages.length, (index) {
              return PopupMenuItem<int>(
                value: index,
                child: Text('Background ${index + 1}'),
              );
            });
          },
          icon: Icon(Icons.image),
        ),
      ],
    );
  }

  @override
  Widget build(BuildContext context) {
    return MaterialApp(
      theme: _isDarkTheme ? ThemeData.dark() : ThemeData.light(),
      home: Scaffold(
        extendBody: true,
        extendBodyBehindAppBar: true,
        //bottomNavigationBar: Text("a"),
        appBar: my_AppBar(),
        body: DecoratedBox(
            decoration: BoxDecoration(
              image: DecorationImage(
                image: AssetImage(_backgroundImages[_selectedBackgroundIndex]),
                fit: BoxFit.cover,
              ),
            ),
            child: Container(
              height: MediaQuery.of(context).size.height * 0.85,
              child: Column(children: [
                //  Text("helo"),
                Flexible(
                  child: ListView.builder(
                    padding: EdgeInsets.all(8.0),
                    reverse: true,
                    itemCount: _messages.length,
                    addAutomaticKeepAlives: true,
                    itemBuilder: (_, int index) =>
                        _buildMessage(_messages[index]),
                  ),
                ),
                if (_botStatus.isNotEmpty)
                  Padding(
                    padding: EdgeInsets.all(4.0),
                    child: Text(
                      _botStatus,
                      style: TextStyle(color: Colors.grey, fontSize: 12),
                    ),
                  ),
                //Divider(height: 1.0),
                Container(
                  decoration: BoxDecoration(color: Colors.blueGrey),
                  //color: const Color.fromARGB(255, 112, 112, 112)),
                  child: _buildTextComposer(),
                ),
              ]),
            )),
      ),
    );
  }
}
